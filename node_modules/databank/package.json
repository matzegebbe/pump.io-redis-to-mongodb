{
  "name": "databank",
  "version": "0.19.1",
  "homepage": "http://github.com/e14n/databank",
  "engines": {
    "node": ">=0.6.x"
  },
  "author": {
    "name": "Evan Prodromou",
    "email": "evan@e14n.com"
  },
  "scripts": {
    "test": "vows test/*-test.js"
  },
  "main": "./lib/index.js",
  "directories": {
    "lib": "./lib/"
  },
  "description": "Abstraction layer for JSON storage",
  "dependencies": {
    "vows": "0.7.x",
    "step": "0.0.x",
    "set-immediate": "~0.1.1"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/e14n/databank.git"
  },
  "readme": "# Databank\n\nThis package is an abstraction tool for document stores or key-value\nstores in Node.js.\n\nMy goal is to hedge my bets by using a simple CRUD + search interface\nfor interacting with a datastore. If at some point I really need the\nspecial snowflake features of Redis or MongoDB or Cassandra or Riak or\nwhatever, I should be able to bust out of this simple abstraction and\nuse their native interface without rewriting a lot of code.\n\nI also want the data structures stored to look roughly like what\nsomeone experienced with the datastore would expect.\n\nI chose the name \"databank\" since it's not in widespread use and won't\ncause name conflicts, and because it sounds like something a 1960s\nrobot would say.\n\nAs a note: I've used this library for a couple of big projects, and\nmostly it just works.\n\n# License\n\nCopyright 2011-2014 E14N https://e14n.com/\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n> http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n# Drivers\n\nThe point of the Databank interface is so applications can use one\ninterface for developing persistence code, and then at deployment time\nyou can decide what driver to use.\n\nThere are three drivers included in this package: 'memory',\n'partitioning', and 'caching'. The first is great for development but\npretty bad for production.\n\nThere are a few drivers not in this package. You can search for them\non npm; they all start with 'databank-'. So, 'databank-leveldb',\n'databank-mongodb', 'databank-memcached', 'databank-redis',\n'databank-disk'.\n\n## Installation\n\nI'm still not 100% on this, so comments welcome. I'd love better\ninstructions.\n\nAt deployment time, if you want to use a particular driver, it's going\nto need to be available to the 'databank' libraries so that\n`Databank.get()` can find it. This means you have two options:\n\n* Install the driver globally, like `npm install -g databank-redis`. This is\n  probably OK as long as you don't have version conflicts between apps.\n* Install the driver in the `databank` dir, like so:\n\n    npm install databank\n\n    cd node_modules/databank/\n\n    npm install databank-redis\n\nIf you're still stuck, there's a `Databank.register()` method that\nwill let you associate a databank driver class with a driver\nname. That's probably only a last resort, though.\n\n## Built-in drivers\n\nThe built-in drivers are documented in MEMORY.md, CACHING.md, and\nPARTITIONING.md respectively.\n\n# Schemata\n\nThis library assumes you have document \"types\" - like \"person\",\n\"chair\", \"photo\", \"bankaccount\", \"trainreservation\" -- that you can\nidentify with a unique scalar key -- email address, URL, UUID, SSN, or\nwhatever.\n\nYour \"document\" is anything that can be JSON-encoded and\ndecoded. Scalar, array and object/tree values are all totally cool.\n\nImplementation classes that support schemata should support a \"schema\"\nelement on the constructor params for `Databank.get()` (see below). A\nschema can have elements for each type, with the following elements:\n\n* pkey: the primary key element name.\n\n* indices: array of element names that should be indexed. You should\n  really have an index on each element you search on frequently.\n\n## Dotted notation\n\nIn schemata you can use dotted-notation, a la MongoDB, to define\nfields that are part of parts of the object. For example, for an\nobject like this:\n\n    { email: \"evan@e14n.com\", name: { last: \"Prodromou\", first: \"Evan\" } }\n\n...you may have a schema like this:\n\n    { person: { pkey: \"email\", indices: [\"name.last\"] } }\n\n# Databank\n\nThe class has a static method for for initializing an instance:\n\n* `get(driver, params)`\n\n  Get an instance of `DriverDatabank` from the module `databank-driver` and\n  initialize it with the provided params (passed as a single object).\n\n  This is the place you should usually pass in a schema parameter.\n\n    var bank = Databank.get('redis', {schema: {person: {pkey: \"email\"}}});\n\n    bank.connect({}, function(err) {\n        if (err) {\n            console.log(\"Couldn't connect to databank: \" + err.message);\n        } else {\n            // ...\n        }\n    });\n\nThere's another static method to change how `get()` works:\n\n* `register(driver, cls)`\n\n   Register a class to use when `get()` asks for `driver`. This is\n   useful if for some reason your driver class isn't exported by the\n   `databank-driver` package somewhere. (I mainly use this for\n   unit-testing drivers.)\n\nThe databank interface has these methods:\n\n* `connect(params, onCompletion)`\n\n  Connect to the databank. `params` may be used by the underlying server.\n\n  `onCompletion` takes one argument: a `DatabankError` object. Null if no error.\n\n* `disconnect(onCompletion)`\n\n  Disconnect from the databank. `onCompletion` takes one argument, a DatabankError.\n\n* `create(type, id, value, onCompletion)`\n\n  Create a databank entry of type `type` with id `id` and content `value`.\n\n  How `type` and `id` are mapped to keys or whatever in the DB is\n  unspecified. Don't mix and match.\n\n  `onCompletion` takes two arguments: a `DatabankError` (or null) and the\n  created object. That created object may have some extra stuff added on.\n\n  Common error type here is `AlreadyExistsError`.\n\n      store.create('activity', uuid, activity, function(err, value) {\n          if (err instanceof AlreadyExistsError) {\n              res.writeHead(409, {'Content-Type': 'application/json'});\n              res.end(JSON.stringify(err.message));\n          } else if (err) {\n              res.writeHead(400, {'Content-Type': 'application/json'});\n              res.end(JSON.stringify(err.message));\n          } else {\n              res.writeHead(200, {'Content-Type': 'application/json'});\n              res.end(JSON.stringify(value));\n          }\n      });\n\n* `read(type, id, onCompletion)`\n\n  Read an object of type `type` with id `id` from the databank. `onCompletion` will get\n  two arguments: a `DatabankError` (or null) and the object if found.\n\n  Common error type here is `NoSuchThingError` if the databank has no such object.\n\n    bank.read('Book', '978-0141439600', function(err, user) {\n        if (err instanceof NoSuchThingError) {\n            res.writeHead(404, {'Content-Type': 'application/json'});\n            res.end(JSON.stringify(err.message));\n        } else if (err) {\n            res.writeHead(500, {'Content-Type': 'application/json'});\n            res.end(JSON.stringify(err.message));\n        } else {\n            res.writeHead(200, {'Content-Type': 'application/json'});\n            res.end(JSON.stringify(user));\n        }\n    });\n\n* `update(type, id, value, onCompletion)`\n\n  Update the (existing) object of type `type` with id `id` in the databank. `onCompletion`\n  will get two arguments: a `DatabankError` (or null) and the object if found.\n\n  Common error type here is `NoSuchThingError` if the databank has no such object.\n\n* `save(type, id, value, onCompletion)`\n\n  Either create a new object, or update an existing object. For when\n  you don't care which.\n\n* `del(type, id, onCompletion)`\n\n  Delete the object of type `type` with id `id`. `onCompletion` takes one\n  argument, a `DatabankError` (null on success).\n\n  \"delete\" is a keyword, so I decided not to use that.\n\n* `search(type, criteria, onResult, onCompletion)`\n\n  Finds objects of type `type` which match `criteria`, a map of\n  property names to exact value matches. `onResult` is called one time\n  for each result, with a single argument, the object that matches the\n  criteria. Use a collector array if you want all the results in an array.\n\n  Property names can be dotted to indicate deeper structures; for\n  example, this object:\n\n    {name: {last: \"Prodromou\", first: \"Evan\"}, age: 43}\n\n  would match the criteria `{\"name.last\": \"Prodromou\"}`.\n\n  `onCompletion` takes one argument, a `DatabankError`. A search with\n  no results will get a `NoSuchThingError`. I think this is the method\n  most likely to elicit a `NotImplementedError`, since most key-value\n  stores don't handle this kind of thing.\n\n  You're also on your own on sorting.\n\n    function getModerators(callback) {\n        var results = [];\n\n        bank.search('user', {role: 'moderator'}, function(result) {\n                        results.push(result);\n                    },\n                    function(err) {\n                        if (err) {\n                            callback(err, null);\n                        } else {\n                            results.sort(function(a, b) {\n                                return a.created - b.created;\n                            });\n                            callback(null, results);\n                        }\n                    });\n    }\n\n* `scan(type, onResult, onCompletion)`\n\n  Finds all objects of type `type`. `onResult` is called one time\n  for each result, with a single argument, the object that matches the\n  criteria. Use a collector array if you want all the results in an array.\n\n  `onCompletion` takes one argument, a `DatabankError`. A search with\n  no results will get a `NoSuchThingError`. I think this is the method\n  most likely to elicit a `NotImplementedError`, since most key-value\n  stores don't handle this kind of thing.\n\n  This is probably most useful for off-line processing, like doing a\n  backup or for initializing roll-up data. At scale, this may take\n  days to complete. If you want to do something like searching a\n  range, figure out a better way, like storing an array of matches at\n  write time.\n\n* `readAll(type, ids, onCompletion)`\n\n  Gets all the objects of type `type` with ids in the array\n  `ids`. Results are an object mapping an id to the results. If an ID\n  doesn't exist, the mapped value will be `null`.\n\n  This is kind of like calling `read` over and over, but if the driver\n  supports multiple reads in one call, it can be much more performant.\n\n  `onCompletion` gets two arguments: an error, and the results map.\n\n## Integers\n\nThese are special shims for integer values.\n\n* `incr(type, id, onCompletion)`\n\n  Increments the integer value of `type` and `id` by\n  one. `onCompletion` takes two params: an error, and the resulting\n  integer value. If integer value doesn't yet exists, goes to 1.\n\n  Defaults to a `read` and an `update` or `create`, but drivers can\n  override to do an atomic increment.\n\n* `decr(type, id, onCompletion)`\n\n  Increments the integer value of `type` and `id` by\n  one. `onCompletion` takes two params: an error, and the resulting\n  integer value. If integer value doesn't yet exists, goes to -1.\n\n  Defaults to a `read` and an `update` or `create`, but drivers can\n  override to do an atomic decrement.\n\n## Arrays\n\nThese are special shims for array values.\n\n* `append(type, id, toAppend, onCompletion)`\n\n  Appends the value `toAppend` to the array at `type` and `id`.\n  `onCompletion` takes one param: an error. If array doesn't yet\n  exists, it becomes a single-element array.\n\n  Defaults to a `read` and an `update` or `create`, but drivers can\n  override to do an atomic append.\n\n* `prepend(type, id, toPrepend, onCompletion)`\n\n  Prepends the value `toPrepend` to the array at `type` and `id`.\n  `onCompletion` takes one param: an error. If array doesn't yet\n  exists, it becomes a single-element array.\n\n  Defaults to a `read` and an `update` or `create`, but drivers can\n  override to do an atomic prepend.\n\n* `item(type, id, index, onCompletion)`\n\n  Gets the value at `index` in the array at `type` and `id`.\n  `onCompletion` takes two params: an error, and the resulting\n  item value.\n\n  Defaults to read the whole array and pluck out the value, but some\n  drivers might support atomic query of just one item.\n\n* `slice(type, id, start, length, onCompletion)`\n\n  Like `Array.slice()`, gets the sub-array starting at index `start`\n  of length `length` of the array at `type` and `id`. `onCompletion`\n  takes two params: `err` for error, and `results` for the resulting\n  slice.\n\n  Defaults to read the whole array and pluck out the slice, but some\n  drivers might support atomic query of a slice.\n\n* `indexOf(type, id, item, onCompletion)`\n\n  Like `Array.indexOf()`, gets the first index of `item` in the array\n  at `type` and `id`. `onCompletion` takes two params: `err` for\n  error, and `index` for the resulting index. Will give an index of -1\n  (like Javascript) on a miss.\n\n* `remove(type, id, item, onCompletion)`\n\n  Like `Array.remove()`, removes the first instance of `item` in the\n  array at `type` and `id`. `onCompletion` takes one params: `err` for\n  error.\n\n# DatabankError\n\nThis is a subclass of `Error` for stuff that went wrong with a\n`Databank`. Subclasses include:\n\n* `NotImplementedError`\n\n  That doesn't work (yet).\n\n* `NoSuchThingError`\n\n  The type/id pair you were trying to read/update/delete doesn't exist.\n\n* `AlreadyExistsError`\n\n  The type/id pair you were trying to create *does* exist.\n\n* `NotConnectedError`\n\n  You forgot to call `connect` first.\n\n* `AlreadyConnectedError`\n\n  You already called `connect`.\n\n* `NoSuchItemError`\n\n  There's no item in that array with that value.\n\n* `WrongTypeError`\n\n  You tried to use one of the array operators on a non-array value.\n\n# DatabankObject\n\nThis is a utility class for objects you want to store in a\nDatabank. To create the class, do this:\n\n    var MyClass = DatabankObject.subClass('mytype');\n\nThis will make an object class that stores data in the 'mytype'\ntype. You can add more stuff to the class, of course.\n\nThe class's `type` is stored in `MyClass.type`.\n\nThe constructor takes an object as a parameter; it will copy all its\nproperties from this object. Good for \"classifying\" JSON. So:\n\n    var json = getSomeJSONfromSomewhere();\n    var myInst = new MyClass(json);\n\nEach class has the following class methods:\n\n* `bank()`\n\nGets the class's databank. Used internally for making queries. By\ndefault, gets the DatabankObject.bank property. If you want to change\nhow this works, replace this function with... something else.\n\n* `pkey()`\n\nGets the class's primary key. By default, looks for a class attribute\n\"schema\" and tries to get the \"pkey\" element of that. Otherwise, it\nchecks the class's schema, looks for an element that matches the type\nname, and tries to get pkey element of that. If that fails, it looks\nat the class's databank's \"schema\", and tries to get that. Otherwise,\nit just returns \"id\". Override if you have a better plan.\n\n* `get(id, callback)`\n\nGet the object with primary key `id` and returns it to the `callback`.\n\n* `search(criteria, callback)`\n\nDoes a search for objects matching the criteria, collects them, and\nreturns an array to `callback`.\n\n* `scan(handler, callback)`\n\nFinds all objects of this type and calls `handler` on each one. At the\nend, fires `callback` with a single `err` parameter.\n\n* `create(properties, callback)`\n\nCreates a new instance of class with `properties` and returns it to callback.\n\n* `readAll(ids, callback)`\n\nReads all objects from the databank with the given array of\nprimary-key ids, and returns a map of {id: object}.\n\n* `readArray(ids, callback)`\n\nReads all objects from the databank with the given array of\nprimary-key ids, and returns an array of objects in the same order.\n\nEach instance has the following methods:\n\n* `update(properties, callback)`\n\nFor an existing object, update to the provided properties, and return\nthe resulting object to `callback`. Note that you can use only a few\nproperties; note that you can't use this method to _remove_ properties.\n\n* `del(callback)`\n\nDelete the object. `callback` takes a single error arg.\n\n* `save(callback)`\n\nSave the current state of the object, and return it to\n`callback`. Will create new objects or update existing ones.\n\n## Hooks\n\nWhen I started using this library, I found myself overloading the\ncreate(), update(), and save() methods to do extra things, like add an\nauto-generated ID or timestamp, or to expand attributes stored by\nreference. It was a little tricky, since I had to save off the default\nauto-created function, then define a new function that called that\nsaved one.\n\nTo make this easier, I added a hooks mechanism. Now, every\nDatabankObject subclass has the option of hooking certain\nfunctionality without having to replicate the core\nfunctionality. Default values are all no-ops.\n\nClass methods:\n\n* `beforeCreate(props, callback)`\n\nCalled before `create()`. A chance to add default values\nor validate. `callback` takes two args: an err, or the (possibly\nmodified) props.\n\nInstance methods:\n\n* `afterCreate(callback)`\n\nCalled after `create()`. Good chance to save references. `callback`\ntakes one arg: an err.\n\n* `beforeGet(id, callback)`\n\nCalled before `get()`. I don't see a lot of reason to mess with\nthis, but it's here if you need it. `callback` takes two args: an err,\nor the (possibly modified) id.\n\n* `afterGet(callback)`\n\nCalled after `get()`. Good chance to expand references. `callback`\ntakes one arg: an err.\n\nThis is also called once for each instance returned in `readAll()`.\n\n* `beforeUpdate(props, callback)`\n\nCalled before `update()`. Validate, preserve immutables, or add\nauto-generated properties. `callback` takes two args: an err and the\n(possibly modified) props.\n\n* `afterUpdate(callback)`\n\nCalled after `update()`. `callback` takes one arg: an err.\n\n* `beforeDel(callback)`\n\nCalled before `del()`. Maybe prevent deleting something important?\nReferential integrity? `callback` takes one arg: an err.\n\n* `afterDel(callback)`\n\nCalled after `del()`. Delete related stuff? `callback` takes one arg:\nan err.\n\n* `beforeSave(callback)`\n\nCalled before `save()`. Validate, preserve, autogenerate. `callback`\ntakes one args: an err.\n\n* `afterSave(callback)`\n\nCalled after `save()`. `callback` takes one args: an err.\n\nTODO\n----\n\nSee https://github.com/e14n/databank/issues\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/e14n/databank/issues"
  },
  "_id": "databank@0.19.1",
  "_from": "databank@"
}
